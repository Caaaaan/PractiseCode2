**本次讲解涉及CCF-CSP认证考试相关的信息，训练计划，二分，KMP，DFS，BFS.**



## CCF-CSP考试简介

<u>中国计算机学会（CCF）</u>联合华为、360、滴滴等十余家知名IT企业以及清华、北航、国防科大等15所著名高校于2014年推出<u>CCF CSP（计算机软件能力）</u>认证标准，用于评价业界人士的计算机软件能力。
**ccfcsp考试报名条件**

报名参加CCF CSP认证者不限年龄，不限学历，不限报考次数，不限国籍，在报名官网注册账户后均可报名参加认证。

**ccfcsp考试时间**

时间一般是每年3、9、12月的中旬，报名时间一般也是提前一个月，不固定。

**ccfcsp考试内容**

对软件开发能力，即使用计算机通过编程语言和算法，编制成能在计算机上稳定运行的软件模块的能力进行考察和认证。

**ccfcsp考试的作用**

1、名企名校录取依据
2、CCF优秀大学生奖评选的必要条件之一

## 训练计划

![1](D:\4+课文档\1.jpg)

## 二分

**什么是二分？**

二分就是一分为二。简单来说二分就是在**<u>有序序列</u>**中，通过不断的将一份分成两份，进而不断地缩小范围去寻找满足我们条件的解。这只是对二分一个狭义上的理解，广义二分其实是如果有一个临界值使得临界值一边的数据满足一种性质，另一边满足另一种性质，即使不是有序的但也可以利用二分去寻找这个临界值。
在竞赛中，二分题目主要分为二分查找、二分答案

**二分类型：**整数二分、实数域上二分

**注意：**

有单调性一定可以二分，可以二分不一定有单调性

二分的本质是边界不是单调性(单调一定可以二分，不单调的有的也可以二分)

### 整数二分

![2](D:\4+课文档\2.jpg)
如果是整数二分（答案是离散的)，答案又两种情况，写代码也有所区别，整数二分模板也分成了两大类。

使用说明：执行完模板代码后，l和r必然相等。此时在数组中访问的arr[r]必然是二分后所指向的端点。

***两种类型在找一个点时用法相同，在找区间时用法不同（上图讲述的就是找区间的用法），可以通过题目进行加深理解***

区间的查找（就是第一个和最后一个的区分）：[P2249 【深基13.例1】查找](https://www.luogu.com.cn/problem/P2249)

（此处讨论从小到大排序的情况）

#### 第一类：目标值是红色区域的右端点

将[L,R]分成[L,M-1],[M,R]，伪代码如下：

**<u>if M是红色的，说明ans，必然在[M,R]之间。</u>**

<u>**else 说明ans必然在[L,M-1]之间。**</u>

**模板代码**

```c++
bool Check(int mid)//判断的条件
{
    //判断mid是否满足一定的条件，一般是看看所找的答案是否在mid的右边，且包括了mid;(其它的判断也行，不过后面的区间变化要做相应的改变)
}
while(l<r)//找右端点，且此处数组已经排完了序
{
    int mid=(l+r+1)/2;//中间位置，且此处的位置都会偏向后面取(此处有加一，所以就向上取整)
    // +1的原因： 防止死循环， 例如l = 4, r = 5, 如果不加1， 此时mid = 4，如果此时mid满足条件， l又会赋值为4， 造成死循环
    // +1后， mid = 5, l = 5, r = 5, 此时l == 5, 循环结束
    if(Check(mid)) l=mid;//arr为排完序的序列，这里因为数组的原因，所以它是离散的(就是整数取整)(如果满足条件就往右边找)
    else r = mid-1;
}
```

#### 第二类：目标值是绿色区域的左端点
将[L,R]分成[L,M],[M+1,R],伪代码如下：

<u>**if M是绿色的，说明ans在[L,M]之间。**</u>

<u>**else 说明ans在[M+1,R]之间。**</u>

**模板代码**

```c++
bool Check(int mid)//判断的条件
{
    //判断mid是否满足一定的条件，一般是看看所找的答案是否在mid的左边，且包括了mid;(其它的判断也行，不过后面的区间变化要做相应的改变)(这里跟上面的右边不一样,是检查左边)
}
while(l<r)//找左端点，且此处数组已经排完了序
{
    int mid=(l+r)/2;//中间位置，且此处的位置都会偏向前面取(此处没有加一，所以就向下取整)
    //这里的原因可以参考上面第一类的理由
    if(Check(mid)) r=mid;//满足条件就往左边找
    else l = mid+1;
}
```

#### 整数二分例题——数的范围
*这道题即用到了查找左端点，也用到了查找右端点。*

给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。

对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。

如果数组中不存在该元素，则返回 -1 -1。

**输入格式**
第一行包含整数 n 和 q，表示数组长度和询问次数。

第二行包含 n 个整数（均在 $1\thicksim 10000$范围内），表示完整数组。

接下来 q 行，每行包含一个整数 k，表示一个询问元素。

**输出格式**
共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。

如果数组中不存在该元素，则返回 ```  -1 -1```.

**数据范围**
$1≤n≤100000$
$1≤q≤10000$
$1≤k≤10000$

**输入样例：**

```
6 3
1 2 2 3 3 4
3
4
5
```

**输出样例：**

```
3 4
5 5
-1 -1
```

**实现代码：**

```c++
#include <cstdio> 
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 100010;
int n,m;
int q[N]; //定义数组，题目已经是排好序的了，就不用排序
int main(void)
{
    cin>>n>>m;
	for(int i=0;i<n;i++) cin>>q[i];
	for(int i=0;i<m;i++)
	{
		int x;
		cin>>x//读x 
		//二分x的左端点
		int l=0,r=n-1;//确定区间范围
		while(l<r)//二分，先向左查找
		{
			int mid=l+r>>1;//除以2可以写>>1  ,+优先级大于>> 
			if(q[mid]>=x) r=mid;
			else l = mid +1;
		} 
		//二分的 
		if(q[r] == x)//x的左端点 
		{
			cout<< r <<' ';//输出左端点 
			//二分x的右端点 
			r = n-1;//右端点一定在[左端点,n-1]之间 
			while(l<r)//向右查找，这里不直接暴力查找的原因是因为怕与x相同的数有很多，所以就继续用二分
			{
				int mid=l+r+1>>1;//因为写的是l=mid，所以需要补上1 
				if(q[mid]<=x) l=mid;
				else r=mid-1;
			}
			cout<< l <<endl;//输出右端点 ，写l和写r都是一样的因为最后l和r必然相等 
		}
		else cout<< "-1 -1" <<endl;//第一次二分的时候找不到就直接输出这个
	}
	return 0;
}
```



### 实数二分

相比较整数上的二分，实数域上的二分就简单很多了，实数域上二分需要注意的点是**确定精度**，这里有一个小技巧，如果题目上让保留k位小数，那么精度eps就设置成$10^{(-k-2)}$

**模板代码**

```c++
bool check()
{
    //具体情况具体分析
}
double l=0,r=1000;//这里l与r的值一定要根据题目来设定，不能想当然的就从0开始
while(r-l>eps){
	double mid=(r-l)/2;
	if(check()) l=mid;
	else r=mid;
} 
```

有的时候精度难以控制，也可以用设立二分次数的方法来控制精度

**模板代码**

```c++
double l=0,r=1000;
for(int i=0;i<100;i++)
{
    double mid=(l+r)/2;
    if(check()) l=mid;
    else r=mid;
}
```

#### 实数二分例题——数的三次方跟

给定一个浮点数 n，求它的三次方根。

**输入格式**

共一行，包含一个浮点数 n。

**输出格式**

共一行，包含一个浮点数，表示问题的解。

注意，结果保留 6 位小数。

**数据范围**

$-10000 \leq n \leq 10000$

**输入样例：**

```
1000.00
```

**输出样例：**

```
10.000000
```

**实现代码：**

```c++
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
int main()
{
	double x;
	cin>>x;
	double l=-10000,r=10000;
	cout<< r-l<<endl;
	while(r-l>1e-8)
	{
		double mid=(l+r)/2;
		if(mid*mid*mid >=x) r=mid;
		else l=mid;
		cout<< r-l<<endl;
	}
	printf("%.6lf",l);
} 
```

#### 二分查找
二分查找也称折半查找，可以提高查找效率，使用的就是上面的方法，所以这里就不再赘述。

#### 二分答案
二分答案全称叫做二分答案转化为判定，这类问题通常用于答案的值域已经确定，并且很难从问题的本身去找到答案，这样就可以从答案值域入手，判定这个值符不符合题目要求，根据判定结果缩小范围从而找到最优值，也是通过上面的方法进行解题，文末的题目中可以进行练习。

## KMP算法

KMP 算法是一种改进的字符串匹配算法，由 D.E.Knuth，J.H.Morris 和 V.R.Pratt 提出的，因此人们称它为克努特 — 莫里斯 — 普拉特操作（简称 KMP 算法）。KMP 算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个 next 函数实现，函数本身包含了模式串的局部匹配信息。KMP 算法的时间复杂度 O (m+n) 。（用来解决字符串的匹配问题）

*以下分三点解析*

### 一、前缀和后缀最长相等长度
首先给定一个字符串$abstkabs$。<br>下面介绍前缀和后缀，前缀就是以第一个字符开始，一共能找出多少种和本身不一样的字符串(必须连续)。意思就是你不能破坏原来字符串的顺序来找，比如$abstkabs$，$abtk$就不行，因为它破坏了原来的顺序结构，即从b直接跳到t。所以$abstkabs$的前缀有$a$、$ab$、$abs$、$abst$、$abstk$、$abstka$、$abstkab$；不计算本身，所以共7种。同理，后缀是以最后一个字符结尾，一共有多少种和本身不一样的字符串。此处后缀有$s$、$bs$、$abs$、$kabs$、$tkabs$、$stkabs$、$bstkabs$共7种。而前缀和后缀中只有abs这个字符串是相等的，所以前缀和后缀中最长的长度就是当前缀和后缀都为abs的时候，即最长相等长度为3。理解这个概念很重要，这也是**<u>next数组</u>**的含义。（后面会讲如何通过算法得到）

现在，我们可以通过取得 `ababc` 所有子串 `[a,ab,aba,abab,ababc]` 的**最长公共前后缀**的长度，分别保存在 `next` 数组中，我们只要知道最大长度即可，并不用关心串具体是什么，而我们目前通过观察即可得出 next 数组这里是 `[0,0,1,2,0]`，我们先知道这个结果即可，此计算方法后续会说明。

### 二、KMP算法的流程

*下面通过字符串匹配的暴力算法引入KMP算法*

一般的字符串匹配解法是将 2 个串的字符进行挨个比较，相当于是把每个字符都比较了一遍，这样是一定能得到结果的，不过显然这样操作导致的时间复杂度是` O (m*n) `，也就是 2 个字符串的长度之积，俗称暴力解法。

用图像表示暴力解法的过程如下：
一开始，i 和 j 分别指向主字符串和子字符串，

![3](D:\4+课文档\3.jpg)

这个时候开始比较 `t[i]` 和 `p[j]`，如果匹配则 i 和 j 同时向右移动一格，这样 i 和 j 同时移动到了位置 3，

![4](D:\4+课文档\4.jpg)

此时 i 和 j 不匹配了，需要对 i 和 j 进行回退，i 回退到了它最开始的下一位置，即位置 1，而 j 回退到位置 0

![5](D:\4+课文档\5.jpg)

此时 i 和 j 仍然不匹配，i 继续向右移动一格，即位置 2，j 依然保持位置 0

![6](D:\4+课文档\6.jpg)

如此反复，每当不匹配时，i 都会回到开始匹配的位置同时移动一格，而 j 回到位置 0，当匹配时，i 和 j 同时向右移动，直到 j 到达子字符串的末尾。

![7](D:\4+课文档\7.jpg)



![8](D:\4+课文档\8.jpg)



**<u>KMP 算法</u>则用了一种聪明的办法，当发现字符串不匹配的时候，并不会从头开始比较，因为之前已经匹配成功的字符可以给我们提供一些有用的信息，利用这个信息我们可以将子串移动到某个位置，并从这个位置直接开始比较，它的时间复杂度降到了 O (m+n) ，也就是 2 个字符串的长度之和。**

回到刚刚的例子，当我们第一次碰到不匹配时（i 和 j 都等于 3 的时候）：

![9](D:\4+课文档\9.jpg)

此时 i 和 j 之前的 3 个字符 `aba` 必然完全匹配的，因为只有前面匹配成功了 j 才能走到 3，而我们又知道 `aba` 的**最长公共前后缀**是 `a`，这可以给我们一个很好的提示，**主串中的 `aba` 的后缀和字串中的 `aba` 前缀有最长的公共部分 `a`**，这样一来，我们就没必要重新比较了，直接将相同部分对齐就好了，也就是说让 j 退回到位置 1 就可以了，而 i 保持不变

![10](D:\4+课文档\10.jpg)

分析一下，为什么 j 知道应该退回到位置 1：

1. 我们知道 j 是在位置 3 不匹配的，那么 j 前面的字符串我们可以知道是 `aba`
2. 通过前面的概念和我们得到的 `next `数组，知道 `aba` 的最长公共前后缀长度是 **1**
3. 也就是说，我们可以知道 i 之前 **1** 个位置（主串的后缀）和子串开头之后 **1** 个位置（子串的前缀）是相同的
4. 进而我们可以让相同部分对齐，也就是让 `j=next[j-1]`

接下来，我们发现 i 和 j 仍然不匹配，而 j 之前的字符 `a` 最长公共前后缀是 0，此时 j 退到位置 0，i 仍然保持不变。

![11](D:\4+课文档\11.jpg)

i 和 j 匹配，同时右移一格

![12](D:\4+课文档\12.jpg)

此时 i 和 j 不匹配，`j=next[j-1]` 回退到 0，然后我们发现 i 和 j 仍然不匹配，同时 j 已经是 0 了，那么我们就让 i 往右移动一格。

![13](D:\4+课文档\13.jpg)



![14](D:\4+课文档\14.jpg)



可以看到，相比于暴力解法，i 始终在前进，并没有后退（顶多保持不变），然后我们通过 next 数组来改变 j 的值,可以很大程度上减少时间复杂度。



### 三、next数组的求解

***其实`next`数组求解的过程类似于上面KMP的主要思想***

我们先初始化一个和模式字符串长度相等的 `next `数组，在 `next `数组中，第 1 位默认为 0，因为我们规定只有一个字符的字符串没有前缀和后缀，自然公共前后缀长度只能是 0。
我们依然设定 2 个指针 i 和 j，j 指向位置 0，i 从位置 1 开始依次为 `next `数组进行赋值

![15](D:\4+课文档\15.jpg)

我们可以把这个过程依然看作是 2 个字符串的比较，j 指向的是模式字符串的前缀，而 i 指向的是模式字符串的后缀

![16](D:\4+课文档\16.jpg)

和上面的字符串匹配一样，我们执行同样的处理：

1. 当 i 和 j 匹配时，i 和 j 同时右移一格
2. 当 i 和 j 不匹配时，如果 j 不在字符串开头（位置 0），就回退到上一个能匹配到的位置
3. 当 i 和 j 不匹配时，如果 j 在字符串开头（位置 0），那么 i 就右移一格

对 `next [1] `赋值：i 和 j 不匹配，同时 j 已经是字符串开头，赋值 0

![17](D:\4+课文档\17.jpg)



对 `next [2]` 赋值，i 和 j 匹配，此时 j 为 0，代表只有 1 个字符匹配 (j+1)，赋值 1

![18](D:\4+课文档\18.jpg)



对 `next [3] `赋值，i 和 j 匹配，此时 j 为 1，代表有 2 个字符匹配 (j+1)，赋值 2

![19](D:\4+课文档\19.jpg)



对` next [4] `赋值，i 和 j 不匹配，此时 j 为 2，可以得知 j 前面的字符是 `ab`，而 `ab` 的最长公共前后缀长度就是 `next[1]`，这个值我们前面已经求得了结果是 0，所以 j 回退到位置 0，用代码表示就是 `j=next[j-1]`

![20](D:\4+课文档\20.jpg)



此时 i 和 j 仍然不匹配，但是 j 已为 0，无法继续回退，所以直接对` next [4] `赋值为 0

![21](D:\4+课文档\21.jpg)



实际上，我们在求解模式字符串 `ababc` 的最长公共前后缀长度的时候，不可避免的会对它的子串进行求解，这样可以方便在不匹配时进行回退，这也是动态规划的思想，要求的结果可以用先前已经求得的结果得出。而我们本身就是要对模式字符串的各个子串进行求解，所以可谓一举两得。

**KMP算法模板**

```c++
#include <cstring>
#include <iostream>
#define maxn 1000
using namespace std;
char s1[maxn];//两个字符串，s1为子串（就是短的串）
char s2[maxn];//长串
int next[maxn];//next数组的长度于s1的长度一致
void getNext()//获得next数组，匹配时用
{
	next[0]=-1;//上文中把第一个定为0，此处定为-1也可以，因为第一个不可能有往前面跳的时候（如果定为0的话算法要进行相应的改变）
	for(int i=0,j=-1;s1[i];)//当s1没有时就结束，i指向被匹配串，j指向匹配串
	(j==-1||s1[i]==s1[j])//如果匹配到相同的或者不能继续往前面跳的时候，两串都要同时往后移动，并且next的相应位置记为0，
    {//因为如果到时这里匹配不成功的话就要从头开始匹配
		i++;//主串往后移
		j++;//子串也往后移
		next[i]=j;//记录最长相同的前后缀
	}else{
		j=next[j];//匹配到不相同的，就要从前面开始找，跳回到上一次可以匹配的地方（要注意，跳的是匹配串）
	}
}
int match(const char s1[],const char s2[])
{
	getNext();//先获得next数组，再进行匹配
	int len=strlen(s1);
	int k,i;
	for(k=0,i=0;s2[k];){
		if(s1[i]==s2[k]||i==-1){//思想类似上面
			k++;
			i++;
			if(!s1[i])//这里是因为子串匹配完成了，就说明找到了地方，就可以退出了
				return k-len;//k-len就是第一个匹配到的地方。
		}else{
			i=next[i];
		}
	}
	return -1;//匹配不到就返回-1;
} 
int main(void)
{
    cin>>s1>>s2;
	int P=match(s1,s2);
    cout<<P<<endl;
}
```

## 图的遍历——DFS和BFS

### 一、深度优先搜索(DFS)
**思想：每次都是走到不能再走了才回到最近的一个交叉口。从图中的某一个顶点 v0 出发，访问此顶点，然后依次从 v0 的没被访问的邻接点出发深度优先遍历图（体现了递归的思想），直至图中所有和 v0 有路径相通的顶点都被访问到；若此时图中仍有结点没有被访问，则另选图中一个未曾访问的顶点作起始点，重复上述过程。**

**`因为要判断某顶点是否被访问过，所以需要vis数组来记录，若访问过则为true，没访问过则为false`**

**DFS伪代码模板（邻接表和邻接矩阵都能套）**

```c++
DFS(u){	//访问顶点u
	vis[u] = true;	//将u设置为已经访问
	for(从u出发能到达的所有顶点)//枚举从u出发能到达的所有顶点
		if vis[v] == false	//如果v没有被访问
			DFS(v);
}
DFSTrave(G)
{
	for(G中的所有顶点u)
		if vis[u] == false
			DFS(u);
}
```

### 二、广度优先搜索(BFS)

**基本思想：**

- **建立一个队列，并且把初始顶点加入队列**
- **此后每次都取出队首顶点进行访问并且把该顶点出发可以达到的未曾加入过队列（而不是未访问）的顶点全部加入队列**
- **直到队列为空。**

**BFS伪代码模板（邻接表和邻接矩阵都能套）**

```c++
BFS(u){//遍历u所在的模块
	queue q;
	inq[u] = true;//设置u已经被加入过队列
	while(q非空){
		取出q的队首元素u进行访问；
		for(从u出发可达的所有顶点v)
			if(inq[v] == false){
				将v入队；
				inq[v] = true;
			}
	}
}
BFSTrave(G){
	for(G的所有结点u)
		if(inq[u] == false)
			BFS(u);
}
```

*对于更加详细的搜索解释，可以前往：*[常用搜索技巧](https://github.com/CSGrandeur/s-1problem1day1ac/discussions/415)

# 题目列表

|题目|题目类型|难度|
|:---:|:---:|:-|
|[【深基13.例1】查找](https://www.luogu.com.cn/problem/P2249)|二分查找|⭐⭐|
|  [一元三次方程求解](https://www.luogu.com.cn/problem/P1024)  | 二分答案 |⭐⭐|
|[眼红的Medusa](https://www.luogu.com.cn/problem/P1571)|二分查找|⭐⭐|
|[ 烦恼的高考志愿](https://www.luogu.com.cn/problem/P1678)|二分查找| ⭐⭐   |
|[木材加工](https://www.luogu.com.cn/problem/P2440)|二分答案| ⭐⭐   |
|[跳石头](https://www.luogu.com.cn/problem/P2678)|二分答案| ⭐⭐⭐  |
|[路标设置](https://www.luogu.com.cn/problem/P3853)|二分答案|⭐⭐⭐|
|[书的复制](https://www.luogu.com.cn/problem/P1281)|二分答案|⭐⭐⭐⭐|
|[【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)|KMP|⭐⭐|
|[Radio Transmission 无线传输](https://www.luogu.com.cn/problem/P4391)|KMP|⭐⭐|
|[OKR-Periods of Words](https://www.luogu.com.cn/problem/P3435)|KMP|⭐⭐⭐|
|[马的遍历](https://www.luogu.com.cn/problem/P1443)|BFS|⭐⭐|
|[八皇后 Checker Challenge](https://www.luogu.com.cn/problem/P1219)|DFS|⭐⭐|
|[填涂颜色](https://www.luogu.com.cn/problem/P1162)|BFS，DFS|⭐⭐⭐|
|[奇怪的电梯](https://www.luogu.com.cn/problem/P1135)|BFS，DFS|⭐⭐|
|[选数](https://www.luogu.com.cn/problem/P1036)|DFS|⭐⭐|
|[单词方阵](https://www.luogu.com.cn/problem/P1101)|DFS|⭐⭐⭐|
|[Schedule Management](https://codeforces.com/contest/1701/problem/C)|二分答案|⭐⭐⭐|
|[Fixed Point Guessing](https://codeforces.com/contest/1698/problem/D)|二分答案|⭐⭐⭐⭐|
|[±1 Operation 2](https://atcoder.jp/contests/abc255/tasks/abc255_d)|二分查找|⭐⭐⭐|
|[Toss a Coin to Your Graph...](https://codeforces.com/contest/1679/problem/D)|二分答案+记忆化搜索|⭐⭐⭐⭐⭐|
|[Binary String](https://codeforces.com/contest/1680/problem/C)|二分答案+尺取|⭐⭐⭐⭐|
|[Distributing Ballot Boxes](https://vjudge.net/problem/HDU-4190)|二分答案|⭐⭐⭐|
|[Cup](https://vjudge.net/problem/HDU-2289)|二分答案|⭐⭐⭐|
|[Drying](https://vjudge.net/problem/POJ-3104#author=0)|二分答案|⭐⭐⭐|
|[矩阵取数](https://ac.nowcoder.com/acm/problem/231670)|二分+搜索|⭐⭐⭐⭐⭐|

# 参考资料：

该文档经过许多的资料转载并且修改，以下为原文的链接

**原文链接：**[一篇文章带你搞懂二分](https://blog.csdn.net/qq_42376883/article/details/121253905)，**作者：**AliceGoretzka

**原文链接：**[二分](https://blog.csdn.net/wwh1st/article/details/115025820)，**作者：**穗余

**原文链接：**[KMP算法详解](https://blog.csdn.net/weixin_44450058/article/details/123772886)，**作者：**宇智波藤原

**原文链接：**[彻底搞懂 KMP 算法原理](https://www.xdull.cn/kmp.html)，**作者：**兜兜转转

**原文链接：**[图的遍历方法——DFS和BFS](https://blog.csdn.net/qq_44166630/article/details/116998250)，**作者：**sin(豪)

**原文链接：**[图的遍历——BFS与DFS](https://blog.csdn.net/m0_50710793/article/details/121677300)，**作者：**艾尔伯特想变瘦
